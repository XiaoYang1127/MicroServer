# 微服务间通信

## 常见的通信方式

- websocket 实现的 http 协议
- rpc
- socket 实现的 tcp/udp 协议

## 消息内容

- 协议号：标识具体功能的请求
- 消息序列号：用于处理消息回调，请求方需要保证该序列号单服唯一
- 消息内容: 业务数据

```python
{
    "cmd": 0x100,
    "seq": 1,
    "content": {"x":"加油", "y":"明天"}
}
```

## 消息格式

- json 字符串
- 二进制流，如 protocolbuf

## 消息压缩算法

- gzip
- snappy

## 消息加密算法

- 用 rsa 算法对 aes 对称秘钥加密
  - 客户端每次重连或登录，都重新生成 rsa 秘钥
  - 建立连接后，客户端将公钥发送给服务器，同时服务器对新生成的 aes 秘钥加密，返回给客户端
  - 客户端收到 rsa 公钥加密后的 aes 秘钥后，解密，即可拿到 aes 对称秘钥
  - 之后，c/s 交互都采用密文进行
- 理由:
  - 加密秘钥仅当次登陆有效，因为协商秘钥所需时间较短
  - 只要私钥不泄漏，就能保证 c/s 消息安全
  - 相比 rsa 而言，用 aes 对消息加密，效率更高

## 设计原则

- 长连接为主，短连接为辅
- 优点:
  - 方便完成服务器的主动通知和推送等功能
  - 方便实现`连接状态`相关的业务，如`在线`, `离线`等

## 最佳实践

- 为了效率和性能考虑，服务器间跨服交互以 tcp 协议 或者 rpc 较好
- 与客户端交互，采用 tcp or http 都行
- 粘包、分包的解决方案
  - 协议格式：Head(4B) + PackID(4B) + FragFlag(1B) + PayloadLen(4B) + Payload(nB)
  - Head: 4 字节，包的长度
  - PackID: 4 字节，包的唯一 id
  - FragFlag: 1 字节，数据包分片标识，0-整包/分片最后一包，1-分片包
  - PayloadLen: 4 字节，指示负载数据长度
  - Payload: 负载数据{act:x,seq:x,data:x...}的字符串内容
